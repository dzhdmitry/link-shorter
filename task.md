Пишем сервис-сокращатель ссылок

# Иттерация 1

Пишем веб-сервер, который умеет принимать HTTP запросы в JSONах и отдавать ответы в формате JSON или редиректы HTTP.

Сервер должен уметь читать конфигурацию из ENV переменных и из Args командной строки. Должно быть можно задавать все базовые настройки: адрес и порт, префикс для сокрщенных ссылок и в дальнейшем все остальные настройки

Сами данные храним в памяти. Запросы могут быть конкурентными, поэтому нужно данные в памяти закрывать локами.

Должна быть ручка POST, которая сокращает входящую ссылку и отдает в ответе сокращенную ссылку. Алгоритм сокращения самой ссылки можно придумать свой или посмотреть в интернете.

Должна быть ручка GET, которая должна принимать сокращенную ссылку и отдавать HTTP редирект на изначальную

Все невалидные запросы должны обрабатываться и в ответ должны отдаваться корректные HTTP статусы

# Иттерация 2

Прикручиваем Логгирование запросов в виде мидлварей и GZIP сжатие при передаче хеддера accept encoding gzip и расжатие при передаче хеддера Content-Encoding gzip от клиента.

# Иттерация 3

Прикручиваем сохранение стейта в локальный файл. Должна быть настройка для синхронного и асинхронного сохранения стейта. При запуске, нужно указывать из какого файла нужно уметь восстанавливаться, если такой есть.

Добавляем batch ручки, которые принимают JSON и отдают JSON с множеством ссылок.

# Иттерация 4

Добавляем возможность хранить данные в постгресе.

Добавляем настройку на сохранение данных в постгрес, а не использования данных в памяти + файлик. Требуется установить соедиенение с базой, делать insert и select из нее, а не из локального стейта.

Во время исполнения запроса, везде должен прокидываться контекст с установленным на входе в ручук таймаутом в 1s. Таймаут на запрос должен настраиваться.

# Иттерация 5

Добавляем кеширование. Требуется реализовать in memory кеширование самых популярных запросов, чтобы они не требовали вызова базы данных

# Иттерация 6

Добавляем ограничение на количество одновременных запросов в сервис и добавляем Rate Limiter, который должен настраиваться максимальным количеством одновременных запросов

При превышении количества одновременных запросов - отдавать хеддер недоступности

# Иттерация 7

Переносим кеширование в Redis / Memcached.
Добавляем настройку на подключение к кешу. Вместо локального кеширования, ходим с запросам сначала в кеш, а потом в бд

# Иттерация 8

Делаем так, чтобы запрос оставался в своей горутине, а обработка запроса, походы в кеш и БД делались в другой горутине. Запрос должен либо дождаться исполнения горутины и вернуть ответ, либо получить ошибку и вернуть ошибку, либо не дождаться ответа и вернуть ошибку о таймауте
